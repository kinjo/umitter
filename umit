#!/usr/bin/env ruby

# -*- coding: utf-8 -*-

require 'uri'
require 'net/http'
require 'rexml/document'
require 'date'
require 'ostruct'
require 'openssl'

Net::HTTP.version_1_2

CONSUMER_KEY    = ''
CONSUMER_SECRET = ''
TOKEN           = ''
TOKEN_SECRET    = ''

class Umitter
  module Weather
    module Helper
      def report(report)
        @report = report
      end
      def weather
        @report
      end
      def hot?; weather.hot?; end
      def cold?; weather.cold?; end
      def east?; weather.wind_east?; end
      def west?; weather.wind_west?; end
      def south?; weather.wind_south?; end
      def north?; weather.wind_north?; end
      def calm?; weather.wind_speed < 5; end
    end

    class Report < OpenStruct
      def cloudy?; /cloud/i =~ conditions ? true : false; end
      def rainy?; /rain/i =~ conditions ? true : false; end
      def storm?; /storm/i =~ conditions ? true : false; end
      def clear?; /clear/i =~ conditions ? true : false; end
      def wind_east?; /E/ =~ wind_direction ? true : false; end
      def wind_west?; /W/ =~ wind_direction ? true : false; end
      def wind_south?; /S/ =~ wind_direction ? true : false; end
      def wind_north?; /N/ =~ wind_direction ? true : false; end
      def hot?; temperature > 24; end
      def cold?; temperature < 20; end
    end

    class Reporter
      module Location
        NAHA_CITY = "47930"
      end

      def self.base_uri
        URI "http://rss.wunderground.com"
      end

      def initialize(opts={})
        default_opts = {:location => Location::NAHA_CITY}
        @body = get(default_opts.merge(opts)) {|response| response.body}
      end

      def self.latest
        new.reports.first
      end

      def reports
        REXML::Document.new(@body).elements.collect('//item') do |e|
          args = e.elements['description'].text.split('|').inject({}) do |a, n|
            case n.strip
            when /^Temperature:\ (.*)/
              /.*?(\d+)&#\d+;C/ =~ $1
              a.merge({ :temperature => $1.to_i })
            when /^Humidity:\ (.*)/
              /(\d+)%/ =~ $1
              a.merge({ :humidity => $1.to_i })
            when /^Pressure:\ (.*)/
              a.merge({ :pressure => $1.to_i })
            when /^Conditions:\ (.*)/
              a.merge({ :conditions => $1 })
            when /^Wind\ Direction:\ (.*)/
              a.merge({ :wind_direction => $1 })
            when /^Wind\ Speed:\ (.*)<.*?>/
              a.merge({ :wind_speed => ($1.scan(/\d+km\/h/).first.gsub('km/h', '').to_f * 1000/3600).round })
            else
              a
            end
          end
          args.update(:at => DateTime.parse(e.elements['title'].text))
          Weather::Report.new args
        end
      end

      private

      def get(opts={}, &block)
        uri = self.class.base_uri
        uri.path = "/auto/rss_full/global/stations/#{opts[:location]}"
        Net::HTTP.start(uri.host) do |http|
          response = http.request Net::HTTP::Get.new(uri.path)
          case response
          when Net::HTTPOK
            block ? block.call(response) : response
          else
            raise
          end
        end
      end
    end
  end

  class SimpleOAuth
    def initialize(consumer_key, consumer_secret, token, token_secret)
      @consumer_key = consumer_key
      @consumer_secret = consumer_secret
      @token = token
      @token_secret = token_secret
      # This class supports only 'HMAC-SHA1' as signature method at present.
      @signature_method = 'HMAC-SHA1'
    end

    def get(url, headers = {})
      request(:GET, url, nil, headers)
    end

    def head(url, headers = {})
      request(:HEAD, url, nil, headers)
    end

    def post(url, body = nil, headers = {})
      request(:POST, url, body, headers)
    end

    def put(url, body = nil, headers = {})
      request(:PUT, url, body, headers)
    end

    def delete(url, headers = {})
      request(:DELETE, url, nil, headers)
    end

    private
    def request(method, url, body = nil, headers = {})
      method = method.to_s
      url = URI.parse(url)
      request = create_http_request(method, url.request_uri, body, headers)
      request['Authorization'] = auth_header(method, url, request.body)
      Net::HTTP.new(url.host, url.port).request(request)
    end

    RESERVED_CHARACTERS = /[^a-zA-Z0-9\-\.\_\~]/

    def escape(value)
      URI.escape(value.to_s, RESERVED_CHARACTERS)
    end

    def encode_parameters(params, delimiter = '&', quote = nil)
      if params.is_a?(Hash)
        params = params.map do |key, value|
          "#{escape(key)}=#{quote}#{escape(value)}#{quote}"
        end
      else
        params = params.map { |value| escape(value) }
      end
      delimiter ? params.join(delimiter) : params
    end

    VERSION = '0.1'
    USER_AGENT = "SimpleOAuth/#{VERSION}"

    def create_http_request(method, path, body, headers)
      method = method.capitalize.to_sym
      request = Net::HTTP.const_get(method).new(path, headers)
      request['User-Agent'] = USER_AGENT
      if method == :Post || method == :Put
        request.body = body.is_a?(Hash) ? encode_parameters(body) : body.to_s
        request.content_type = 'application/x-www-form-urlencoded'
        request.content_length = (request.body || '').length
      end
      request
    end

    def auth_header(method, url, body)
      parameters = oauth_parameters
      parameters[:oauth_signature] = signature(method, url, body, parameters)
      'OAuth ' + encode_parameters(parameters, ', ', '"')
    end

    OAUTH_VERSION = '1.0'

    def oauth_parameters
      {
        :oauth_consumer_key => @consumer_key,
        :oauth_token => @token,
        :oauth_signature_method => @signature_method,
        :oauth_timestamp => timestamp,
        :oauth_nonce => nonce,
        :oauth_version => OAUTH_VERSION
      }
    end

    def timestamp
      Time.now.to_i.to_s
    end

    def nonce
      OpenSSL::Digest::Digest.hexdigest('MD5', "#{Time.now.to_f}#{rand}")
    end

    def signature(*args)
      base64(digest_hmac_sha1(signature_base_string(*args)))
    end

    def base64(value)
      [ value ].pack('m').gsub(/\n/, '')
    end

    def digest_hmac_sha1(value)
      OpenSSL::HMAC.digest(OpenSSL::Digest::SHA1.new, secret, value)
    end

    def secret
      escape(@consumer_secret) + '&' + escape(@token_secret)
    end

    def signature_base_string(method, url, body, parameters)
      method = method.upcase
      base_url = signature_base_url(url)
      parameters = normalize_parameters(parameters, body, url.query)
      encode_parameters([ method, base_url, parameters ])
    end

    def signature_base_url(url)
      URI::HTTP.new(url.scheme, url.userinfo, url.host, nil, nil, url.path,
                    nil, nil, nil)
    end

    def normalize_parameters(parameters, body, query)
      parameters = encode_parameters(parameters, nil)
      parameters += body.split('&') if body
      parameters += query.split('&') if query
      parameters.sort.join('&')
    end
  end

  include Weather::Helper

  def initialize(opts={})
    report(opts[:report] || Umitter::Weather::Reporter.latest)
    @file = opts[:acts_as]
    @tweets = []
    @behaviors = []
    @oauth = SimpleOAuth.new(CONSUMER_KEY,
                                 CONSUMER_SECRET,
                                 TOKEN,
                                 TOKEN_SECRET)
  end

  def post
    response = @oauth.post('http://twitter.com/statuses/update.json', {:status => twitter})
    raise "Request failed: #{response.code}" unless response.code.to_i == 200
  end

  def twitter
    instance_eval(File.read(@file))
    tweet
  end

  def tweet
    @tweets.shuffle.first.to_s
  end

  def custom_helper(&block)
    Weather::Helper.module_eval &block
  end

  def it(condition=true, &block)
    u = self.class.new :weather => weather
    u.instance_eval &block
    if @tweets.shuffle.any?
      @tweets.shuffle.first << u.tweet
    else
      @tweets << u.tweet
    end
  end

  def m(tweet)
    @tweets << tweet
  end
end

Umitter.new(:acts_as => ARGV[0]).post
